# tests/test_unit/test_flask_app.py

import os
import pytest
import werkzeug
from io import BytesIO
from flask import flash
from app.app import app
from tools.utils.logger import logger
from tools.modules.database_functions import (
    patient_variant_table,
    variant_annotations_table,
    validate_database,
    query_db
)

@pytest.fixture
def flask_app():
    """
    This function prepares a fake environment to run our flask app for monkeypatch pytesting.
    Flask_app makes the app callable in subsequent pytests where monkeypatch is used to emulate the app.
    """

    # This dictionary like object changes the flask app configuration.
    app.config.update({
        # The flask app is switch to 'test mode'.
        "TESTING": True,
        # Access to apps typically use a token which represents the User's identification and their activity.
        # This is disabled so that a fake environment can be created to execute pytests.
        "WTF_CSRF_ENABLED": False
    })

    # The app is returned.
    return app

@pytest.fixture
def client(flask_app):
    """
    This function prepares a fake flask app test client for monkeypatch pytesting. This allows GET and POST requests to
    be pytested.

    :params: flask_app: The output from the flask_app pytest fixture. This is essentially a testable version of our
                        flask app.

    :output: flask_app.test_client(): A fake flask app test client.
    """
    # Return the fake flask app test client.
    return flask_app.test_client()

# ----------------------------------------------------------------
# Test Homepage-GET: files removed from temp folder.
# ----------------------------------------------------------------
def test_homepage_cleans_temp_folder(client, monkeypatch):
    """
    This function tests if the route to the homepage in app.py adequately removes .VCF and .CSV file from the 'temp'
    folder, as soon as the flask app has been initialised.
    Monkeypatch creates a fake path to two fake files: one VCF and one CSV.

    :param: client: A fake test client generated by the 'client' pytest fixture.
            monkeypatch: The pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcomes: Test that a response was received successfully.
                    Test that if files were removed from the 'temp' folder.
    """

    # Create an empty list to store the paths to the removed files.
    removed = []

    # Monkeypatch simulates a VCF and CSV file in the temp folder using os.listdir in app.py. lambda converts the values
    # in the list into filenames.
    monkeypatch.setattr("app.app.os.listdir", lambda path: ["a.vcf", "b.csv"])
    # Monkeypatch repurposes os.remove in app.py to add the paths of the files that were removed, to the 'removed' list
    # variable.
    monkeypatch.setattr("app.app.os.remove", lambda path: removed.append(path))

    # The homepage in app.py is specified in the route by a '/'. This is applied to the client function output to 'get'
    # a response during which os.remove is used.
    response = client.get("/")

    # A status code of 200 indicates that the simulated response was received successfully.
    assert response.status_code == 200
    # The length of the 'removed' list is checked to ensure that both files were removed.
    assert len(removed) == 2

# ----------------------------------------------------------------
# Test Homepage-POST: No files uploaded to temp folder.
# ----------------------------------------------------------------
def test_add_variant_no_files(client):
    """
    This function tests if the route to the homepage in app.py reports that the 'temp' folder is empty.
    The 'form_type' and 'db_file' are required to test the "Create or Add to a Database" part of the app.

    :param: client: A fake test client generated by the 'client' pytest fixture.

    :test outcomes: Test that a response was received successfully.
                    Test that "A variant file was not uploaded" is returned.
    """
    # Simulate a POST request from the "Create or Add to a Database" section on the homepage by selecting the
    # 'add_variant' form type and assigning a fake database name to 'db_file'.
    response = client.post("/", data={
        #
        "form_type": "add_variant",
        "db_file": "test.db"
    })

    # A status code of 200 indicates that the simulated response was received successfully.
    assert response.status_code == 200
    # Test that app.py returned 'A variant file was not uploaded' when a database was being added to/created while no
    # files has been uploaded.
    assert b"A variant file was not uploaded" in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: Invalid file extension.
# ----------------------------------------------------------------
def test_add_variant_invalid_extension(client):
    """
    This function tests if app.py reports that an invalid file type was uploaded, i.e. the file was not a VCF or CSV
    file.
    The 'form_type', 'db_file' and 'variant_files' are required to test this aspect of the "Create or Add to a Database"
    portion of the app.

    :param: client: A fake test client generated by the 'client' pytest fixture.

    :test outcome: Test that "Invalid file type" is returned by the app.
    """

    # Create a dict variable which stores the parameters required to test what happens if an invalid file is uploaded.
    data = {
        # This tests the 'Create or Add to a Database' functionality in app.py.
        "form_type": "add_variant",
        # A fake database name is provided.
        "db_file": "test.db",
        # Simulates the upload of a .txt file, which is not a VCF or CSV file, and should cause the expected message to
        # be returned.
        "variant_files": (BytesIO(b"fake"), "bad.txt")
    }

    # Use request POST to retrieve the simulated response from the app.
    response = client.post("/", data=data, content_type="multipart/form-data")

    # Test that "Invalid file type" is returned, as expected.
    assert b"Invalid file type. Please upload .VCF or .CSV files only." in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: Successful upload of variants to a database.
# ----------------------------------------------------------------
def test_add_variant_invalid_extension(client, monkeypatch):
    """
    This function tests if app.py can successfully upload a variant file and populate a database with the variants from
    the file. This is signified by the return of the message, "Added sample.vcf to database".
    Monkeypatch creates fake parameters to test the patient_variant_table() and variant_annotations_table() database
    functions, as well as os.remove.
    The 'form_type', 'db_file' and 'variant_files' are required to test this aspect of the "Create or Add to a Database"
    portion of the app.

    :param: client: A fake test client generated by the 'client' pytest fixture.

    :test outcome: Test that a response was successfully received.
                   Test that "Added sample.vcf to database" is returned by the app.
    """

    # Monkeypatch creates a fake environment to initialise patient_variant_table() and variant_annotations_table().
    monkeypatch.setattr("app.app.patient_variant_table", lambda *args: None)
    monkeypatch.setattr("app.app.variant_annotations_table", lambda *args: None)
    # Monkeypatch also simulates os.remove without deleting any real files.
    monkeypatch.setattr("app.app.os.remove", lambda *args: None)

    # Create a dict variable which stores the parameters required to test what happens if a .VCF file is uploaded.
    data = {
        # This tests the 'Create or Add to a Database' functionality in app.py.
        "form_type": "add_variant",
        # A fake database name is provided.
        "db_file": "test.db",
        # Simulates the upload of a .VCF file, which should be processed without error by the app.
        "variant_files": (BytesIO(b"fake"), "sample.vcf")
    }

    # Use request POST to retrieve the simulated response from the app.
    # follow_redirects=True simulates the full User workflow after form submission.
    response = client.post("/", data=data, content_type="multipart/form-data", follow_redirects=True)

    # A status code of 200 indicates that the simulated response was received successfully.
    assert response.status_code == 200
    # Test that "Added sample.vcf to database" is returned, indicating that the variant file was successfully uploaded
    # to the database.
    assert b"Added sample.vcf to database" in response.data