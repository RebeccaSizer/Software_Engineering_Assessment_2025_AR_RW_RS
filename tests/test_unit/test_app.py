# tests/test_unit/test_flask_app.py

import os
import errno
import pytest
import sqlite3
import werkzeug
from io import BytesIO
from flask import flash
from app.app import app
from tools.utils.logger import logger
from tools.modules.database_functions import (
    patient_variant_table,
    variant_annotations_table,
    validate_database,
    query_db
)

# ----------------------------------------------------------------
# Pytest fixtures
# ----------------------------------------------------------------
@pytest.fixture
def flask_app():
    """
    This function prepares a fake environment to run our flask app for monkeypatch pytesting.
    Flask_app makes the app callable in subsequent pytests where monkeypatch is used to emulate the app.
    """

    # This dictionary like object changes the flask app configuration.
    app.config.update({
        # The flask app is switch to 'test mode'.
        "TESTING": True,
        # Access to apps typically use a token which represents the User's identification and their activity.
        # This is disabled so that a fake environment can be created to execute pytests.
        "WTF_CSRF_ENABLED": False
    })

    # The app is returned.
    return app

@pytest.fixture
def client(flask_app):
    """
    This function prepares a fake flask app test client for monkeypatch pytesting. This allows GET and POST requests to
    be pytested.

    :params: flask_app: The output from the flask_app pytest fixture. This is essentially a testable version of our
                        flask app.

    :output: flask_app.test_client(): A fake flask app test client.
    """
    # Return the fake flask app test client.
    return flask_app.test_client()

# ----------------------------------------------------------------
# Exceptions for testing app.py:
#   - PermissionError
#   - ENOSPC
#   - OSError
#   - General exception
#   - SQLite3.DatabaseError
#   - SQLite3.OperationalError
# ----------------------------------------------------------------
def raise_permission(*args, **kwargs):
    """
    Function raises the PermissionError exception. This error occurs when the User does not have permission to use a
    file.
    """
    # Raise the exception with the error message, "no permission".
    raise PermissionError("no permission")

def raise_enospc(*args, **kwargs):
    """
    Function raises the OSError exception: ENOSPC. This error occurs when there is no more disk space to store a file.
    """
    # Raise the exception with the error message, "No space".
    raise OSError(errno.ENOSPC, "No space")

def raise_oserror(*args, **kwargs):
    """
    Function raises OSError exceptions. This error occurs when there is an issue with the Operating System.
    """
    # Raise the exception with the error message, "IO error".
    raise OSError(errno.EIO, "IO error")

def raise_generic(*args, **kwargs):
    """
    Function raises all exceptions that were not captured by previous error handlers.
    """
    # Raise th exception with the error message, "unexpected".
    raise Exception("unexpected")

def raise_sqlite_de(*args, **kwargs):
    """
    Function raises sqlite3.DatabaseError exceptions. They occur when databases cannot be processed.
    """
    # Raise the exception with the error message, "bad db".
    raise sqlite3.DatabaseError("bad db")

def raise_sqlite_oe(*args, **kwargs):
    """
    Function raises sqlite3.OperationalError exceptions. They occur when SQLite3 is not functioning correctly.
    """
    # Raise the exception with the error message, "cannot open".
    raise sqlite3.OperationalError("cannot open")


# ----------------------------------------------------------------
# Test Homepage-GET: files removed from temp folder.
# ----------------------------------------------------------------
def test_homepage_cleans_temp_folder(client, monkeypatch):
    """
    This function tests if the route to the homepage in app.py adequately removes .VCF and .CSV file from the 'temp'
    folder, as soon as the flask app has been initialised.
    Monkeypatch creates a fake path to two fake files: one VCF and one CSV.

    :param: client: A fake test client generated by the 'client' pytest fixture.
            monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be
                         altered.

    :test outcomes: Test that a response was received successfully (status code 200).
                    Test that if files were removed from the 'temp' folder.
    """

    # Create an empty list to store the paths to the removed files.
    removed = []

    # Monkeypatch simulates a VCF and CSV file in the temp folder using os.listdir in app.py. lambda converts the values
    # in the list into filenames.
    monkeypatch.setattr("app.app.os.listdir", lambda path: ["a.vcf", "b.csv"])
    # Monkeypatch repurposes os.remove in app.py to add the paths of the files that were removed, to the 'removed' list
    # variable.
    monkeypatch.setattr("app.app.os.remove", lambda path: removed.append(path))

    # The homepage in app.py is specified in the route by a '/'. This is applied to the client function output to 'get'
    # a response during which os.remove is used.
    response = client.get("/")

    # A status code of 200 indicates that the simulated response was received successfully.
    assert response.status_code == 200
    # The length of the 'removed' list is checked to ensure that both files were removed.
    assert len(removed) == 2

# ----------------------------------------------------------------
# Test Homepage-POST: No files uploaded to temp folder.
# ----------------------------------------------------------------
def test_add_variant_no_files(client):
    """
    This function tests if the route to the homepage in app.py reports that the 'temp' folder is empty.
    The 'form_type' and 'db_file' are required to test the "Create or Add to a Database" part of the app.

    :param: client: A fake test client generated by the 'client' pytest fixture.

    :test outcomes: Test that a response was received successfully (status code 200).
                    Test that "A variant file was not uploaded" is returned.
    """
    # Simulate a POST request from the "Create or Add to a Database" section on the homepage by selecting the
    # 'add_variant' form type and assigning a fake database name to 'db_file'.
    response = client.post("/", data={
        #
        "form_type": "add_variant",
        "db_file": "test.db"
    })

    # A status code of 200 indicates that the simulated response was received successfully.
    assert response.status_code == 200
    # Test that app.py returned 'A variant file was not uploaded' when a database was being added to/created while no
    # files has been uploaded.
    assert b"A variant file was not uploaded" in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: Invalid variant file extension.
# ----------------------------------------------------------------
def test_add_variant_invalid_extension(client):
    """
    This function tests if app.py reports that an invalid file type was uploaded, i.e. the file was not a VCF or CSV
    file.
    The 'form_type', 'db_file' and 'variant_files' are required to test this aspect of the "Create or Add to a Database"
    portion of the app.

    :param: client: A fake test client generated by the 'client' pytest fixture.

    :test outcome: Test that "Invalid file type" is returned by the app.
    """

    # Create a dict variable which stores the parameters required to test what happens if an invalid file is uploaded.
    data = {
        # This tests the 'Create or Add to a Database' functionality in app.py.
        "form_type": "add_variant",
        # A fake database name is provided.
        "db_file": "test.db",
        # Simulates the upload of a .txt file, which is not a VCF or CSV file, and should cause the expected message to
        # be returned.
        "variant_files": (BytesIO(b"fake"), "bad.txt")
    }

    # Use request POST to retrieve the simulated response from the app.
    response = client.post("/", data=data, content_type="multipart/form-data")

    # Test that "Invalid file type" is returned, as expected.
    assert b"Invalid file type. Please upload .VCF or .CSV files only." in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: Successful upload of variants to a database.
# ----------------------------------------------------------------
def test_add_variant_success(client, monkeypatch):
    """
    This function tests if app.py can successfully upload a variant file and populate a database with the variants from
    the file. This is signified by the return of the message, "Added sample.vcf to database".
    Monkeypatch creates fake parameters to test the patient_variant_table() and variant_annotations_table() database
    functions, as well as os.remove.
    The 'form_type', 'db_file' and 'variant_files' are required to test this aspect of the "Create or Add to a Database"
    portion of the app.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that a response was successfully received (status code 200).
                   Test that "Added sample.vcf to database" is returned by the app.
    """

    # Monkeypatch creates a fake environment to initialise patient_variant_table() and variant_annotations_table().
    monkeypatch.setattr("app.app.patient_variant_table", lambda *args: None)
    monkeypatch.setattr("app.app.variant_annotations_table", lambda *args: None)
    # Monkeypatch also simulates os.remove without deleting any real files.
    monkeypatch.setattr("app.app.os.remove", lambda *args: None)

    # Create a dict variable which stores the parameters required to test what happens if a .VCF file is uploaded.
    data = {
        # This tests the 'Create or Add to a Database' functionality in app.py.
        "form_type": "add_variant",
        # A fake database name is provided.
        "db_file": "test.db",
        # Simulates the upload of a .VCF file, which should be processed without error by the app.
        "variant_files": (BytesIO(b"fake"), "sample.vcf")
    }

    # Use request POST to retrieve the simulated response from the app.
    # follow_redirects=True simulates the full User workflow after form submission.
    response = client.post("/", data=data, content_type="multipart/form-data", follow_redirects=True)

    # A status code of 200 indicates that the simulated response was received successfully.
    assert response.status_code == 200
    # Test that "Added sample.vcf to database" is returned, indicating that the variant file was successfully uploaded
    # to the database.
    assert b"Added sample.vcf to database" in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: Failure to populate a database.
# ----------------------------------------------------------------
def test_add_variant_db_failure(client, monkeypatch):
    """
    This function tests if app.py can handle a failure to populate a database appropriately, without crashing. This is
    signified by the return of the message, ".db was not created/updated" and a status code of 200.
    Monkeypatch creates fake parameters to test the patient_variant_table() and variant_annotations_table() database
    functions.
    The 'form_type', 'db_file' and 'variant_files' are required to test this aspect of the "Create or Add to a Database"
    portion of the app.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that a response was successfully received (status code 200).
                   Test that ".db was not created/updated" is returned by the app.
    """

    # Monkeypatch creates a fake environment to initialise patient_variant_table() and variant_annotations_table().
    monkeypatch.setattr("app.app.patient_variant_table", lambda *args: "error")
    monkeypatch.setattr("app.app.variant_annotations_table", lambda *args: "error")

    # Create a dict variable which stores the parameters required to test what happens if a .VCF file is uploaded.
    data = {
        # This form-type tests the 'Create or Add to a Database' functionality in app.py.
        "form_type": "add_variant",
        # A fake database name is provided.
        "db_file": "test.db",
        # Simulates the upload of a .VCF file, which should be processed without error by the app.
        "variant_files": (BytesIO(b"fake"), "sample.vcf")
    }

    # Use request POST to retrieve the simulated response from the app.
    # follow_redirects=True simulates the full User workflow after form submission.
    response = client.post(
        "/",
        data=data,
        content_type="multipart/form-data",
        follow_redirects=True
    )

    # A status code of 200 indicates that the simulated response was received successfully.
    assert response.status_code == 200
    # Test that ".db was not created/updated" is returned, indicating that the database functions failed but were
    # handled appropriately.
    assert b".db was not created/updated" in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: PermissionError on variant file upload.
# ----------------------------------------------------------------
def test_add_variant_permission_error(monkeypatch, client):
    """
    This function tests if app.py can successfully handle PermissionError exceptions at the point of uploading a variant
    file to a database. Successful error handling is signified by the return of the message, "Failed to save sample.vcf.
    Permission denied." 'sample.vcf' is the name of a fake variant file utilised in this test.
    Monkeypatch creates fake parameters to raise the PermissionError exception.
    The 'form_type', 'db_file' and 'variant_files' are required to test this aspect of the "Create or Add to a Database"
    portion of the app.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that "Failed to save sample.vcf. Permission denied." is returned by the app.
    """
    # Monkeypatch simulates a PermissionError exception raised from saving a variant file to the folder pretending to be
    # the 'temp' folder.
    monkeypatch.setattr(
        "werkzeug.datastructures.FileStorage.save",
        lambda *a, **k: (_ for _ in ()).throw(PermissionError("no permission"))
    )

    # Create a dict variable which stores the parameters required to test what happens if a .VCF file is uploaded.
    data = {
        # This tests the 'Create or Add to a Database' functionality in app.py.
        "form_type": "add_variant",
        # A fake database name is provided.
        "db_file": "test.db",
        # Simulates the upload of a .VCF file.
        "variant_files": (BytesIO(b"fake"), "sample.vcf")
    }

    # Use request POST to retrieve the simulated response from the app.
    response = client.post("/", data=data, content_type="multipart/form-data")

    # Test that "Failed to save sample.vcf. Permission denied." is returned, indicating that the PermissionError
    # exception was handled successfully.
    assert b"Failed to save sample.vcf. Permission denied." in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: ENOSPC exception on variant file upload.
# ----------------------------------------------------------------
def test_add_variant_disk_full(monkeypatch, client):
    """
    This function tests if app.py can successfully handle OSError- ENOSPC exceptions that are raised when there is no
    more diskspace, at the point of uploading a variant file to a database. Successful error handling is signified by
    the return of the message, "Failed to save sample.vcf. There is a problem with your disk space." 'sample.vcf' is the
    name of a fake variant file utilised in this test.
    Monkeypatch creates fake parameters to raise the ENOSPC exception.
    The 'form_type', 'db_file' and 'variant_files' are required to test this aspect of the "Create or Add to a Database"
    portion of the app.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that "Failed to save sample.vcf. There is a problem with your disk space." is returned by the
                   app.
    """
    # Monkeypatch simulates an ENOSPC exception raised from saving a fake variant file to the folder pretending to be
    # the 'temp' folder.
    monkeypatch.setattr(
        "werkzeug.datastructures.FileStorage.save",
        raise_enospc
    )

    data = {
        # This tests the 'Create or Add to a Database' functionality in app.py.
        "form_type": "add_variant",
        # A fake database name is provided.
        "db_file": "test.db",
        # Simulates the upload of a .VCF file.
        "variant_files": (BytesIO(b"fake"), "sample.vcf")
    }

    # Use request POST to retrieve the simulated response from the app.
    response = client.post("/", data=data, content_type="multipart/form-data")

    # Test that "Failed to save sample.vcf. There is a problem with your disk space." is returned, indicating that the
    # ENOSPC exception was handled successfully.
    assert b"Failed to save sample.vcf. There is a problem with your disk space." in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: OSError exception on variant file upload.
# ----------------------------------------------------------------
def test_add_variant_os_error(monkeypatch, client):
    """
    This function tests if app.py can successfully handle OSError exceptions that are raised when there is a problem
    with the operating system, at the point of uploading a variant file to a database. Successful error handling is
    signified by the return of the message, "Failed to save sample.vcf. There is an issue with the operating system:"
    'sample.vcf' is the name of a fake variant file utilised in this test.
    Monkeypatch creates fake parameters to raise the OSError exception.
    The 'form_type', 'db_file' and 'variant_files' are required to test this aspect of the "Create or Add to a Database"
    portion of the app.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that "Failed to save sample.vcf. There is an issue with the operating system:" is returned by
                   the app.
    """
    # Monkeypatch simulates an OSError exception raised from saving a fake variant file to the folder pretending to be
    # the 'temp' folder.
    monkeypatch.setattr(
        "werkzeug.datastructures.FileStorage.save",
        raise_oserror
    )

    data = {
        # This tests the 'Create or Add to a Database' functionality in app.py.
        "form_type": "add_variant",
        # A fake database name is provided.
        "db_file": "test.db",
        # Simulates the upload of a .VCF file.
        "variant_files": (BytesIO(b"fake"), "sample.vcf")
    }

    # Use request POST to retrieve the simulated response from the app.
    response = client.post("/", data=data, content_type="multipart/form-data")

    # Test that "Failed to save sample.vcf. There is an issue with the operating system:" is returned, indicating that
    # OSError exceptions are handled successfully.
    assert b"Failed to save sample.vcf. There is an issue with the operating system:" in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: Invalid database file extension.
# ----------------------------------------------------------------
def test_upload_db_invalid_extension(client):
    """
    This function tests if app.py reports that an invalid database file type was uploaded, i.e. the file does not have a
    .db extension.
    The 'form_type' and 'db_file' are required to test this aspect of the "Upload a Database to Query" portion of the
    app.

    :param: client: A fake test client generated by the 'client' pytest fixture.

    :test outcome: Test that "Invalid file type" is returned by the app.
    """
    # Create a dict variable which stores the parameters required to test what happens if the wrong type of database
    # file is uploaded.
    data = {
        # This form-type tests the 'Upload a Database to Query' functionality in app.py.
        "form_type": "upload_db",
        # A fake database, with a .txt extension, is provided. This should not work as it does not end in .db.
        "database_file": (BytesIO(b"fake"), "notadb.txt")
    }

    # Use request POST to retrieve the simulated response from the app.
    # follow_redirects=True simulates the full User workflow after form submission.
    response = client.post(
        "/",
        data=data,
        content_type="multipart/form-data",
        follow_redirects=True
    )

    # Test that "Invalid file type" is returned, indicating that the database file was not uploaded and the failure was
    # handled appropriately.
    assert b"Invalid file type. Please upload a .db file." in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: Database validation check failure.
# ----------------------------------------------------------------
def test_upload_db_validation_failure(monkeypatch, client):
    """
    This function tests if app.py can handle a failure to validate a database according to a predesigned schema, without
    crashing. Failure to validate a database returns the message, "cannot be queried. Inappropriate tables or headers."
    and a status code of 200.
    Monkeypatch creates fake parameters to test the database using the validate_database() database function.
    The 'form_type' and 'db_file' are required to test this aspect of the "Upload a Database to Query" portion of the
    app.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that a response was successfully received (status code 200).
                   Test that "cannot be queried. Inappropriate tables or headers." is returned by the app.
    """

    # Monkeypatch creates a fake environment to initialise the validate_database() database function to validate the
    # database's schema.
    monkeypatch.setattr("app.app.validate_database", lambda path: False)
    # Monkeypatch also simulates os.remove without deleting any real files.
    monkeypatch.setattr("app.app.os.remove", lambda path: None)

    # Create a dict variable which stores the parameters required to test what happens if the wrong type of database
    # file is uploaded.
    data = {
        # This form-type tests the 'Upload a Database to Query' functionality in app.py.
        "form_type": "upload_db",
        # A fake database is provided. This should not work as it does not conform with the schema used by the
        # validate_database() function.
        "database_file": (BytesIO(b"fake"), "bad.db")
    }

    # Use request POST to retrieve the simulated response from the app.
    # follow_redirects=True simulates the full User workflow after form submission.
    response = client.post(
        "/",
        data=data,
        content_type="multipart/form-data",
        follow_redirects=True
    )

    # A status code of 200 indicates that the simulated response was received successfully.
    assert response.status_code == 200
    # Test that "cannot be queried. Inappropriate tables or headers." is returned, indicating that the database did not
    # pass the validation but its failure was handled appropriately.
    assert b"cannot be queried. Inappropriate tables or headers." in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: Successful upload of a database to query.
# ----------------------------------------------------------------
def test_upload_db_success(monkeypatch, client):
    """
    This function tests if app.py can successfully validate a database file and redirect the User to the query page,
    essentially testing the full scope of the app's "Upload a Database to Query" section. A successful test is signified
    by the route to the query page appearing in the response's 'Location' header.
    Monkeypatch creates fake parameters to test the database using the validate_database() database function. If the
    validation is successful, the User would be redirected to the query page.
    The 'form_type' and 'db_file' are required to test this aspect of the Upload a Database to Query" portion of the
    app.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that the query page was successfully redirected to without accessing it (status code 302).
                   Test that "/query" appears in the response's 'Location' header.
    """
    # Monkeypatch creates a fake environment to initialise the validate_database() database function to validate the
    # database's schema.
    monkeypatch.setattr("app.app.validate_database", lambda path: True)

    # Create a dict variable which stores the parameters required to test what happens if the database is successfully
    # uploaded.
    data = {
        # This form-type tests the 'Upload a Database to Query' functionality in app.py.
        "form_type": "upload_db",
        # A fake database is provided.
        "database_file": (BytesIO(b"fake"), "good.db")
    }

    # Use request POST to retrieve the simulated response from the app.
    # follow_redirects=False simulates the successful generation of the query page without actually accessing the page.
    # This ensures that the query page route appears in the response's 'Location' header. If it were true, the response
    # would consist of the query page's content.
    response = client.post(
        "/",
        data=data,
        content_type="multipart/form-data",
        follow_redirects=False
    )

    # A status code of 302 indicates that the query page was found but the response does not contain any of the page's
    # content. This is intended because the test does not want to access the page, only know that it was successfully
    # generated as result of a successful validation.
    assert response.status_code == 302
    # Test that the response derives from the query page, where the User should have been diverted to if the validation
    # was successful.
    assert "/query" in response.headers["Location"]

# ----------------------------------------------------------------
# Test Homepage-POST: PermissionError on database file upload.
# ----------------------------------------------------------------
def test_add_variant_permission_error(monkeypatch, client):
    """
    This function tests if app.py can successfully handle PermissionError exceptions at the point of uploading a
    database file to a database. Successful error handling is signified by the return of the message, "Failed to save
    test.db database. Permission denied." 'test.db' is the name of a fake database file utilised in this test.
    Monkeypatch creates fake parameters to raise the PermissionError exception.
    The 'form_type' and 'db_file' are required to test this aspect of the "Upload a Database to Query" portion of the
    app.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that "Failed to save test.db. Permission denied." is returned by the app.
    """
    # Monkeypatch simulates a PermissionError exception raised from saving a variant file to the folder pretending to be
    # the 'temp' folder.
    monkeypatch.setattr(
        "werkzeug.datastructures.FileStorage.save",
        lambda *a, **k: (_ for _ in ()).throw(PermissionError())
    )

    # Create a dict variable which stores the parameters required to test what happens if a .VCF file is uploaded.
    data = {
        # This tests the 'Upload a Database to Query' functionality in app.py.
        "form_type": "upload_db",
        # A fake database name is provided.
        "database_file": (BytesIO(b"db"), "test.db")
    }

    # Use request POST to retrieve the simulated response from the app.
    response = client.post("/", data=data, content_type="multipart/form-data")

    # Test that "Failed to save test.db. Permission denied." is returned, indicating that the PermissionError
    # exception was handled successfully.
    assert b"Failed to save test.db database. Permission denied." in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: ENOSPC exception on database file upload.
# ----------------------------------------------------------------
def test_add_variant_disk_full(monkeypatch, client):
    """
    This function tests if app.py can successfully handle OSError- ENOSPC exceptions that are raised when there is no
    more diskspace, at the point of uploading a database file. Successful error handling is signified by the return of
    the message, "Failed to save test.db. There is a problem with your disk space." 'test.db' is the name of a fake
    database file utilised in this test.
    Monkeypatch creates fake parameters to raise the ENOSPC exception.
    The 'form_type' and 'db_file' are required to test this aspect of the "Upload a Database to Query" portion of the
    app.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that "Failed to save test.db. There is a problem with your disk space." is returned by the
                   app.
    """
    # Monkeypatch simulates an ENOSPC exception raised from saving a fake variant file to the folder pretending to be
    # the 'temp' folder.
    monkeypatch.setattr(
        "werkzeug.datastructures.FileStorage.save",
        raise_enospc
    )

    data = {
        # This tests the 'Upload a Database to Query' functionality in app.py.
        "form_type": "upload_db",
        # A fake database name is provided.
        "database_file": (BytesIO(b"db"), "test.db")
    }

    # Use request POST to retrieve the simulated response from the app.
    response = client.post("/", data=data, content_type="multipart/form-data")

    # Test that "Failed to save test.db. There is a problem with your disk space." is returned, indicating that the
    # ENOSPC exception was handled successfully.
    assert b"Failed to save test.db. There is a problem with your disk space." in response.data

# ----------------------------------------------------------------
# Test Homepage-POST: OSError exception on database file upload.
# ----------------------------------------------------------------
def test_add_variant_os_error(monkeypatch, client):
    """
    This function tests if app.py can successfully handle OSError exceptions that are raised when there is a problem
    with the operating system, at the point of uploading a database file. Successful error handling is signified by the
    return of the message, "Failed to save test.db. There is an issue with the operating system:" 'test.db' is the name
    of a fake database file utilised in this test.
    Monkeypatch creates fake parameters to raise the OSError exception.
    The 'form_type' and 'db_file' are required to test this aspect of the "Upload a Database to Query" portion of the
    app.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that "Failed to save test.db. There is an issue with the operating system:" is returned by
                   the app.
    """
    # Monkeypatch simulates an OSError exception raised from saving a fake variant file to the folder pretending to be
    # the 'temp' folder.
    monkeypatch.setattr(
        "werkzeug.datastructures.FileStorage.save",
        raise_oserror
    )

    data = {
        # This tests the 'Upload a Database to Query' functionality in app.py.
        "form_type": "upload_db",
        # A fake database name is provided.
        "database_file": (BytesIO(b"db"), "test.db")
    }

    # Use request POST to retrieve the simulated response from the app.
    response = client.post("/", data=data, content_type="multipart/form-data")

    # Test that "Failed to save test.db. There is an issue with the operating system:" is returned, indicating that
    # OSError exceptions are handled successfully.
    assert b"Failed to save test.db. There is an issue with the operating system:" in response.data

# --------------------------------------------------------------------
# Classes to simulate SQLite databases and functionality on Query page
# --------------------------------------------------------------------
class FakeCursor:
    """
    FakeCursor class simulates a fake cursor that can execute SQLite3 commands in Python.
    """
    def execute(self, *_):
        """
        Simulate the execution of a successful SQLite3 command.
        """
        pass
    def fetchall(self):
        """
        Return a result from the execution.
        """
        return [("P1",)]

class FakeConn:
    """
    Simulate the sqlite3.connect() function.
    """
    def cursor(self):
        """
        Simulates a fake cursor to connect, query and retrieve data from the SQLite3 database from FakeCursor.
        """
        return FakeCursor()

    def __enter__(self):
        """
        Simulates a 'with' block instance to initialise FakeConn.
        """
        return self

    def __exit__(self, *a):
        """
        Simulates the commitment and closing of the connection to the SQLite3 database, thereby ending the 'with'
        block.
        """
        pass

# --------------------------------------------------------------------
# Test Query page-GET: Successful upload of a database to query.
# --------------------------------------------------------------------
def test_query_get_success(monkeypatch, client):
    """
    This function tests if app.py can successfully connect to a database file via SQLite3. A successful connection is
    signified by a response status code of 200 and a rendered db_query_page.html page in the response. If an SQLite3
    database could not be connected to, the User would otherwise be directed to the homepage where the homepage.html
    would be rendered.
    Monkeypatch creates a fake environment in which a fake database can be queried. This prevents pytests from using,
    disturbing or relying on real clinical data and databases.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that a response was successfully received (status code 200).
                   Test that the db_query_page.html page is rendered by the flask app.
    """
    # Monkeypatch simulates the existence of an SQLite3 database file.
    monkeypatch.setattr("app.app.os.listdir", lambda *_: ["test.db"])
    # Monkeypatch also simulates a fake check to determine if the SQLite3 database exists using the os.path.exists
    # function from app.py.
    monkeypatch.setattr("app.app.os.path.exists", lambda *_: True)
    # Monkeypatch simulates the sqlite3.connect function from app.py to connect to a fake database.
    monkeypatch.setattr("app.app.sqlite3.connect", lambda *_: FakeConn())

    # Retrieve the route to the flask app's query page to query the fake test.db database.
    response = client.get("/query/test.db")

    # A status code of 200 indicates that the simulated query page was received successfully.
    assert response.status_code == 200
    # Test that the db_query_page.html was rendered in the response. If an SQLite database could not be connected to
    # User would be redirected to the homepage.
    assert b"db_query_page.html" in response.data

# --------------------------------------------------------------------
# Test Query page-GET: Database not found.
# --------------------------------------------------------------------
def test_query_get_db_missing(monkeypatch, client):
    """
    This function tests if app.py can successfully function while the selected database file is missing. When the
    database file cannot be found, the response should return status code 302 because the User would otherwise
    be redirected to the homepage. Therefore, the homepage.html page should be rendered in the response and the route to
    the homepage ('/') should be assigned to the response's 'Location' attribute. Furthermore, the message, "You should
    be redirected automatically to the target URL" should also be returned in the response.
    Monkeypatch creates a fake environment in which a fake database cannot be found. This prevents using, disturbing or
    relying on real clinical data and databases.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that the homepage was successfully redirected to, without accessing it (status code 302).
                   Test that the route to the homepage.html page is assigned to the response's 'Location' attribute.
                   Test that "You should be redirected automatically to the target URL" is returned.
    """
    # Monkeypatch simulates a fake database file called 'test.db' using the os.listdir function from app.py.
    monkeypatch.setattr("app.app.os.listdir", lambda *_: ["test.db"])
    # Monkeypatch then ensures that the os.path.exists function cannot find the file, thereby simulating that the
    # database file is missing.
    monkeypatch.setattr("app.app.os.path.exists", lambda *_: False)

    # Use request GET to retrieve the simulated response from the app.
    # follow_redirects=False simulates the successful generation of the homepage without actually accessing the page.
    # This ensures that the query page route appears in the response's 'Location' header. If it were true, the response
    # would consist of content from the homepage.
    response = client.get("/query/test.db", follow_redirects=False)

    # A status code of 302 indicates that the homepage was found but the response does not contain any of the page's
    # content. This is intended because the test does not want to access the page, only know that it was successfully
    # generated as result of a successful error handler.
    assert response.status_code == 302
    # Test that the response derives from the homepage, which the User should have been diverted to if the
    # FileNotFoundError exception was handled correctly.
    assert "/" in response.headers["Location"]
    # Test that "You should be redirected automatically to the target URL" is returned, indicating that
    # FileNotFoundError exception is handled successfully.
    assert b"You should be redirected automatically to the target URL" in response.data

# --------------------------------------------------------------------
# Test Query page-GET: Database storage folder not found.
# --------------------------------------------------------------------
def test_query_get_no_db_folder(monkeypatch, client):
    """
    This function tests if app.py can successfully handle the FileNotFoundError exception. If the FileNotFoundError
    exception was handled successfully, the response should return status code of 302 because the hUser would otherwise
    be redirected to the homepage. Therefore, the homepage.html page should be rendered in the response and the route to
    the homepage ('/') should be assigned to the response's 'Location' attribute. Furthermore, the message, "You should
    be redirected automatically to the target URL" should also be returned in the response.
    Monkeypatch creates a fake environment in which the FileNotFoundError exception is raised without using, disturbing
    or relying on real clinical data and databases.

    :param: client: A fake test client generated by the 'client' pytest fixture.
       monkeypatch: An in-built pytest fixture that allows attributes and variables used in a software to be altered.

    :test outcome: Test that the homepage was successfully redirected to, without accessing it (status code 302).
                   Test that the route to the homepage.html page is assigned to the response's 'Location' attribute.
                   Test that "You should be redirected automatically to the target URL" is returned.
    """
    # Monkeypatch simulates a FileNotFoundError exception that is raised because the folder where the database file
    # should be stored does not exist.
    monkeypatch.setattr(
        "app.app.os.listdir",
        lambda *_: (_ for _ in ()).throw(FileNotFoundError())
    )

    # Use request GET to retrieve the simulated response from the app.
    # follow_redirects=False simulates the successful generation of the homepage without actually accessing the page.
    # This ensures that the query page route appears in the response's 'Location' header. If it were true, the response
    # would consist of the homepage's content.
    response = client.get("/query/test.db", follow_redirects=False)

    # A status code of 302 indicates that the homepage was found but the response does not contain any of the page's
    # content. This is intended because the test does not want to access the page, only know that it was successfully
    # generated as result of a successful error handler.
    assert response.status_code == 302
    # Test that the response derives from the homepage, which the User should have been diverted to if the
    # FileNotFoundError exception was handled correctly.
    assert "/" in response.headers["Location"]
    # Test that "You should be redirected automatically to the target URL" is returned, indicating that
    # FileNotFoundError exception is handled successfully.
    assert b"You should be redirected automatically to the target URL" in response.data

# --------------------------------------------------------------------
# Test Query page-POST: Successful queries.
# --------------------------------------------------------------------
def test_patient_query_success(monkeypatch, client):
    # Monkeypatch simulates the existence of an SQLite3 database file.
    monkeypatch.setattr("app.app.os.listdir", lambda *_: ["test.db"])
    # Monkeypatch also simulates a fake check to determine if the SQLite3 database exists using the os.path.exists
    # function from app.py.
    monkeypatch.setattr("app.app.os.path.exists", lambda *_: True)
    # Monkeypatch simulates the sqlite3.connect function from app.py to connect to a fake database.
    monkeypatch.setattr("app.app.sqlite3.connect", lambda *_: FakeConn())

    #monkeypatch.setattr("app.app.query_db", lambda *a, **k: [{"patient_ID": "P1", "variant_NC": "NC_1"}])

    calls = {}

    def fake_patient_query(db, query, params, one=False):
        """
        This function replicates the query_db() database function, which converts entries from an SQLite database
        returned by the patient_id query in app.py, into value in a dict.
        This function is fake and returns a simple dictionary for proof of concept, however, monkeypatch still requires
        the same number of arguments as the query_db() function.

        :param: None of the arguments are real.

        :output: A simple dictionary for proof of concept that the patient query works:
                 E.g.: [{"patient_ID": "P1"}]
        """
        calls["query"] = query
        calls["params"] = params
        return [{"patient_ID": "P1"}]

    monkeypatch.setattr("app.app.query_db", fake_patient_query)

    response = client.post("/query/test.db", data={"patient_ID": "P1"})

    assert response.status_code == 200
    assert "FROM patient_variant" in calls["query"]
    assert calls["params"] == ("P1",)