# tests/test_variant_tables.py
# these tests were written by ChatGPT based on the variant module code as they were more complicated than
# normal tests as they required creation of dummy databases and a monkeypatching of external service calls.
import os
import sqlite3
import pytest

# ðŸ” CHANGE THIS to the actual module path of the code you shared
# e.g. from app.database_functions import patient_variant_table, ...
import tools.modules.database_functions as mod


def _db_path_for(module, db_name: str) -> str:
    """Rebuild the DB path exactly as the production code does."""
    script_dir = os.path.dirname(os.path.abspath(module.__file__))
    return os.path.abspath(
        os.path.join(script_dir, "..", "..", "databases", f"{db_name}.db")
    )


# -----------------------------
# Tests for patient_variant_table
# -----------------------------


def test_patient_variant_table_creates_table_and_inserts_rows(tmp_path, monkeypatch):
    # Create a temp "temp" directory with one VCF file
    temp_dir = tmp_path / "temp"
    temp_dir.mkdir()
    vcf_path = temp_dir / "Patient1.vcf"
    vcf_path.write_text("dummy content")

    # Capture flash messages
    flashed = []

    def fake_flash(msg):
        flashed.append(msg)

    monkeypatch.setattr(mod, "flash", fake_flash)

    # Mock variant_parser to return two variants
    def fake_variant_parser(path):
        assert path.endswith("Patient1.vcf")
        return ["c.123A>T", "c.456G>C"]

    monkeypatch.setattr(mod, "variant_parser", fake_variant_parser)

    # Mock fetch_vv to return HGVS NC_ genomic descriptions
    def fake_fetch_vv(variant):
        if variant == "c.123A>T":
            return ("NC_000001.1:g.123A>T", "NM_dummy", "NP_dummy", "GENE1", 1)
        elif variant == "c.456G>C":
            return ("NC_000001.1:g.456G>C", "NM_dummy", "NP_dummy", "GENE1", 1)
        else:
            raise ValueError("Unexpected variant")

    monkeypatch.setattr(mod, "fetch_vv", fake_fetch_vv)

    # Avoid slowing tests
    monkeypatch.setattr(mod.time, "sleep", lambda s: None)

    db_name = "test_patient_variant_table"
    db_path = _db_path_for(mod, db_name)
    # Ensure clean slate
    if os.path.exists(db_path):
        os.remove(db_path)

    # Run function under test
    mod.patient_variant_table(str(temp_dir), db_name)

    # Assert DB file exists
    assert os.path.exists(db_path)

    # Check table contents
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    cur.execute("SELECT patient_ID, variant FROM patient_variant ORDER BY variant;")
    rows = cur.fetchall()
    conn.close()

    # Expect two variants for Patient1
    assert len(rows) == 2
    assert {r[0] for r in rows} == {"Patient1"}
    variants = {r[1] for r in rows}
    assert "NC_000001.1:g.123A>T" in variants
    assert "NC_000001.1:g.456G>C" in variants


def test_patient_variant_table_no_variant_files(tmp_path, monkeypatch):
    # Empty temp directory
    temp_dir = tmp_path / "temp"
    temp_dir.mkdir()

    # Capture flash messages
    flashed = []

    def fake_flash(msg):
        flashed.append(msg)

    monkeypatch.setattr(mod, "flash", fake_flash)

    # Avoid hitting real VariantValidator / parser
    monkeypatch.setattr(mod, "variant_parser", lambda path: [])
    monkeypatch.setattr(mod, "fetch_vv", lambda v: None)
    monkeypatch.setattr(mod.time, "sleep", lambda s: None)

    db_name = "test_patient_variant_no_files"
    db_path = _db_path_for(mod, db_name)
    if os.path.exists(db_path):
        os.remove(db_path)

    mod.patient_variant_table(str(temp_dir), db_name)

    # Should have flashed the "no files" warning
    assert any("No varaint files have been uploaded" in msg for msg in flashed)

    # DB should still exist
    assert os.path.exists(db_path)

    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    cur.execute("SELECT COUNT(*) FROM patient_variant;")
    (count,) = cur.fetchone()
    conn.close()

    # No rows inserted
    assert count == 0


# -----------------------------
# Tests for variant_annotations_table
# -----------------------------


def test_variant_annotations_table_populates_table(tmp_path, monkeypatch):
    temp_dir = tmp_path / "temp"
    temp_dir.mkdir()
    vcf_path = temp_dir / "Patient1.vcf"
    vcf_path.write_text("dummy content")

    flashed = []

    def fake_flash(msg):
        flashed.append(msg)

    monkeypatch.setattr(mod, "flash", fake_flash)

    # Mock parser and external services
    def fake_variant_parser(path):
        assert path.endswith("Patient1.vcf")
        return ["c.123A>T"]

    monkeypatch.setattr(mod, "variant_parser", fake_variant_parser)

    def fake_fetch_vv(variant):
        assert variant == "c.123A>T"
        return (
            "NC_000001.1:g.123A>T",
            "NM_000001.1:c.123A>T",
            "NP_000001.1:p.Met1?",
            "GENE1",
            1234,
        )

    monkeypatch.setattr(mod, "fetch_vv", fake_fetch_vv)

    def fake_clinvar_annotations(nc, nm):
        return {
            "classification": "Pathogenic",
            "conditions": "Some condition",
            "stars": "â˜…â˜…",
            "reviewstatus": "criteria provided, multiple submitters, no conflicts",
        }

    monkeypatch.setattr(mod, "clinvar_annotations", fake_clinvar_annotations)

    monkeypatch.setattr(mod.time, "sleep", lambda s: None)

    db_name = "test_variant_annotations_table"
    db_path = _db_path_for(mod, db_name)
    if os.path.exists(db_path):
        os.remove(db_path)

    mod.variant_annotations_table(str(temp_dir), db_name)

    assert os.path.exists(db_path)

    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    cur.execute(
        """
        SELECT variant_NC, variant_NM, variant_NP, gene, HGNC_ID,
               Classification, Conditions, Stars, Review_status
        FROM variant_annotations;
        """
    )
    rows = cur.fetchall()
    conn.close()

    assert len(rows) == 1
    (
        variant_nc,
        variant_nm,
        variant_np,
        gene,
        hgnc_id,
        classification,
        conditions,
        stars,
        review_status,
    ) = rows[0]

    assert variant_nc == "NC_000001.1:g.123A>T"
    assert variant_nm == "NM_000001.1:c.123A>T"
    assert variant_np == "NP_000001.1:p.Met1?"
    assert gene == "GENE1"
    assert hgnc_id == 1234
    assert classification == "Pathogenic"
    assert conditions == "Some condition"
    assert stars == "â˜…â˜…"
    assert "criteria provided" in review_status


def test_variant_annotations_table_no_files_returns_early(tmp_path, monkeypatch):
    temp_dir = tmp_path / "temp"
    temp_dir.mkdir()

    flashed = []

    def fake_flash(msg):
        flashed.append(msg)

    monkeypatch.setattr(mod, "flash", fake_flash)

    # These should never be called, but patch to be safe
    monkeypatch.setattr(mod, "variant_parser", lambda path: ["should_not_be_used"])
    monkeypatch.setattr(mod, "fetch_vv", lambda v: None)
    monkeypatch.setattr(mod, "clinvar_annotations", lambda nc, nm: None)
    monkeypatch.setattr(mod.time, "sleep", lambda s: None)

    db_name = "test_variant_annotations_no_files"
    db_path = _db_path_for(mod, db_name)
    if os.path.exists(db_path):
        os.remove(db_path)

    result = mod.variant_annotations_table(str(temp_dir), db_name)

    # Function returns early (implicitly None)
    assert result is None

    # Should flash "No data files have been uploaded"
    assert any("No data files have been uploaded" in msg for msg in flashed)

    # DB should NOT have been created because it returns before connecting
    assert not os.path.exists(db_path)


# -----------------------------
# Tests for validate_database
# -----------------------------


def test_validate_database_true_for_correct_schema(tmp_path):
    db_path = tmp_path / "valid_schema.db"
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()

    # Create tables with expected schema
    cur.execute(
        """
        CREATE TABLE patient_variant (
            No INTEGER PRIMARY KEY,
            patient_ID TEXT NOT NULL,
            variant TEXT NOT NULL
        );s
        """
    )
    cur.execute(
        """
        CREATE TABLE variant_annotations (
            No INTEGER PRIMARY KEY,
            variant_NC TEXT NOT NULL,
            variant_NM TEXT NOT NULL,
            variant_NP TEXT NOT NULL,
            gene TEXT NOT NULL,
            HGNC_ID INTEGER NOT NULL,
            Classification TEXT NOT NULL,
            Conditions TEXT NOT NULL,
            Stars TEXT,
            Review_status TEXT NOT NULL
        );
        """
    )
    conn.commit()
    conn.close()

    assert mod.validate_database(str(db_path)) is True


def test_validate_database_false_if_missing_table(tmp_path):
    db_path = tmp_path / "missing_table.db"
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()

    # Only create one table
    cur.execute(
        """
        CREATE TABLE patient_variant (
            No INTEGER PRIMARY KEY,
            patient_ID TEXT NOT NULL,
            variant TEXT NOT NULL
        );
        """
    )
    conn.commit()
    conn.close()

    assert mod.validate_database(str(db_path)) is False


def test_validate_database_false_if_missing_column(tmp_path):
    db_path = tmp_path / "missing_column.db"
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()

    # Missing the "variant" column
    cur.execute(
        """
        CREATE TABLE patient_variant (
            No INTEGER PRIMARY KEY,
            patient_ID TEXT NOT NULL
        );
        """
    )
    conn.commit()
    conn.close()

    assert mod.validate_database(str(db_path)) is False


# -----------------------------
# Tests for query_db
# -----------------------------


def test_query_db_returns_rows(tmp_path):
    db_path = tmp_path / "query_db.db"
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()

    cur.execute("CREATE TABLE t (id INTEGER, value TEXT);")
    cur.execute("INSERT INTO t (id, value) VALUES (?, ?)", (1, "a"))
    cur.execute("INSERT INTO t (id, value) VALUES (?, ?)", (2, "b"))
    conn.commit()
    conn.close()

    rows = mod.query_db(str(db_path), "SELECT id, value FROM t ORDER BY id;")
    assert len(rows) == 2
    # sqlite3.Row objects support dict-style access
    assert rows[0]["id"] == 1
    assert rows[0]["value"] == "a"
    assert rows[1]["id"] == 2
    assert rows[1]["value"] == "b"


def test_query_db_one_true_returns_single_row_or_none(tmp_path):
    db_path = tmp_path / "query_db_one.db"
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()

    cur.execute("CREATE TABLE t (id INTEGER, value TEXT);")
    cur.execute("INSERT INTO t (id, value) VALUES (?, ?)", (1, "a"))
    conn.commit()
    conn.close()

    row = mod.query_db(
        str(db_path), "SELECT id, value FROM t WHERE id = ?", (1,), one=True
    )
    assert row is not None
    assert row["id"] == 1
    assert row["value"] == "a"

    # Query that returns no rows
    row_none = mod.query_db(
        str(db_path), "SELECT id, value FROM t WHERE id = ?", (999,), one=True
    )
    assert row_none is None