"""
Flask web application for querying variant databases.
------------------------------------------------------
Features:
 - Upload and validate SQLite databases
 - Select from existing databases
 - Query by Patient, Variant, or Gene
 - View variants, annotations, and patient counts
 - Auto-updating dropdowns populated from the selected database

 This code in this script and accompanying html files was written with the assistance of ChatGPT.  The ideas for the features incorporated in the 
 app were generated by the programmers and user in collaboration (except the addition of a drop down list 
 of uploaded databases on the query page, which was suggested by ChatGPT (whereas that acknowledgement was autocompleted by
 Copilot!))).  
"""

import os
import sqlite3
from flask import Flask, render_template, request, redirect, url_for, flash, jsonify

# ---------------------------------------------------------------
# Flask setup
# ---------------------------------------------------------------
app = Flask(__name__)
app.secret_key = "supersecretkey"
app.config["UPLOAD_FOLDER"] = "uploads"
os.makedirs(app.config["UPLOAD_FOLDER"], exist_ok=True)

# ---------------------------------------------------------------
# Expected database schema
# ---------------------------------------------------------------
EXPECTED_SCHEMA = {
    "patient_variant": {'No', 'patient_ID', 'variant'},
    "variant_annotations": {
        'No', 'variant', 'variant_NM', 'gene', 'HGNC_ID',
        'Classification', 'Conditions', 'Stars', 'Review_status'
    },
}


# ---------------------------------------------------------------
# Utility: validate database schema
# ---------------------------------------------------------------
def validate_database(db_path):
    """Check whether the uploaded database matches expected tables and columns."""
    try:
        with sqlite3.connect(db_path) as conn:
            cur = conn.cursor()
            cur.execute("SELECT name FROM sqlite_master WHERE type='table';")
            tables = {row[0] for row in cur.fetchall()}

            if not EXPECTED_SCHEMA.keys() <= tables:
                return False

            for table, expected_cols in EXPECTED_SCHEMA.items():
                cur.execute(f"PRAGMA table_info({table});")
                cols = {row[1] for row in cur.fetchall()}
                if not expected_cols <= cols:
                    return False
        return True
    except Exception:
        return False


# ---------------------------------------------------------------
# Utility: execute queries and return results
# ---------------------------------------------------------------
def query_db(db_path, query, args=(), one=False):
    """Execute SQL query on a database and return results as sqlite3.Row objects."""
    with sqlite3.connect(db_path) as conn:
        conn.row_factory = sqlite3.Row
        cur = conn.execute(query, args)
        rv = cur.fetchall()
        return (rv[0] if rv else None) if one else rv


# ---------------------------------------------------------------
# Route: Home page - upload or select a database
# ---------------------------------------------------------------
@app.route("/", methods=["GET", "POST"])
def upload_db():
    """Allow user to upload a new database or select an existing one."""
    databases = [f for f in os.listdir(app.config["UPLOAD_FOLDER"]) if f.endswith(".db")]
    databases.sort()

    # Selecting existing database
    if request.form.get("existing_db"):
        selected_db = request.form.get("existing_db")
        return redirect(url_for("query_page", db_name=selected_db))

    # Uploading new database
    if request.method == "POST" and "database_file" in request.files:
        file = request.files.get("database_file")
        if not file or file.filename == "":
            flash("No file selected.")
            return render_template("Flask_Home.html", databases=databases)

        filename = file.filename
        if not filename.endswith(".db"):
            flash("Please upload a .db SQLite file.")
            return render_template("Flask_Home.html", databases=databases)

        filepath = os.path.join(app.config["UPLOAD_FOLDER"], filename)
        file.save(filepath)

        if not validate_database(filepath):
            flash("❌ File is not a database in correct form.")
            os.remove(filepath)
        else:
            flash("✅ Database uploaded and validated successfully.")
            return redirect(url_for("query_page", db_name=filename))

    return render_template("Flask_Home.html", databases=databases)


# ---------------------------------------------------------------
# Route: Query page - patient, variant, or gene searches
# ---------------------------------------------------------------
@app.route("/query/<db_name>", methods=["GET", "POST"])
def query_page(db_name):
    """Main query interface for a specific database."""
    # Get list of uploaded databases
    databases = [f for f in os.listdir(app.config["UPLOAD_FOLDER"]) if f.endswith(".db")]
    databases.sort()

    db_path = os.path.join(app.config["UPLOAD_FOLDER"], db_name)
    if not os.path.exists(db_path):
        flash("Database not found.")
        return redirect(url_for("upload_db"))

    data = None
    result_type = None

    # Load dropdown values
    with sqlite3.connect(db_path) as conn:
        cur = conn.cursor()
        cur.execute("SELECT DISTINCT patient_ID FROM patient_variant ORDER BY patient_ID ASC;")
        patient_list = [row[0] for row in cur.fetchall()]

        cur.execute("SELECT DISTINCT variant FROM variant_annotations ORDER BY variant ASC;")
        variant_list = [row[0] for row in cur.fetchall()]

        cur.execute("SELECT DISTINCT gene FROM variant_annotations ORDER BY gene ASC;")
        gene_list = [row[0] for row in cur.fetchall()]

    # Handle search submission
    if request.method == "POST":
        patient_ID = request.form.get("patient_ID")
        variant = request.form.get("variant")
        gene = request.form.get("gene")

        if patient_ID:
            query = """
            SELECT pv.variant, v.variant_NM, v.gene, v.HGNC_ID, v.Classification,
                   v.Conditions, v.Stars, v.Review_status
            FROM patient_variant pv
            JOIN variant_annotations v ON pv.variant = v.variant
            WHERE pv.patient_ID = ?
            """
            data = query_db(db_path, query, (patient_ID,))
            result_type = "patient"

        elif variant:
            query = """
            SELECT v.variant, v.variant_NM, v.gene, v.HGNC_ID, v.Classification,
                   v.Conditions, v.Stars, v.Review_status,
                   COUNT(pv.patient_ID) AS Patient_Count
            FROM variant_annotations v
            LEFT JOIN patient_variant pv ON v.variant = pv.variant
            WHERE v.variant = ?
            GROUP BY v.variant
            """
            data = query_db(db_path, query, (variant,))
            result_type = "variant"

        elif gene:
            lookup_query = "SELECT DISTINCT HGNC_ID FROM variant_annotations WHERE gene = ?"
            hgnc_row = query_db(db_path, lookup_query, (gene,), one=True)

            if hgnc_row:
                hgnc_id = hgnc_row["HGNC_ID"]
                query = """
                SELECT v.variant, v.variant_NM, v.gene, v.HGNC_ID, v.Classification,
                       v.Conditions, v.Stars, v.Review_status,
                       COUNT(pv.patient_ID) AS Patient_Count
                FROM variant_annotations v
                LEFT JOIN patient_variant pv ON v.variant = pv.variant
                WHERE v.HGNC_ID = ?
                GROUP BY v.variant, v.variant_NM, v.gene, v.HGNC_ID,
                         v.Classification, v.Conditions, v.Stars, v.Review_status
                ORDER BY Patient_Count DESC
                """
                data = query_db(db_path, query, (hgnc_id,))
                result_type = "gene"
            else:
                flash(f"No HGNC_ID found for gene '{gene}'.")
                data = None

    return render_template(
        "Flask_Query.html",
        db_name=db_name,
        databases=databases,
        data=data,
        result_type=result_type,
        patient_list=patient_list,
        variant_list=variant_list,
        gene_list=gene_list
    )


# ---------------------------------------------------------------
# Route: JSON API - return dropdown data for live updates
# ---------------------------------------------------------------
@app.route("/api/dropdown/<db_name>")
def dropdown_data(db_name):
    """Return JSON lists of patients, variants, and genes for the current database."""
    db_path = os.path.join(app.config["UPLOAD_FOLDER"], db_name)
    if not os.path.exists(db_path):
        return jsonify({"error": "Database not found"}), 404

    with sqlite3.connect(db_path) as conn:
        cur = conn.cursor()
        cur.execute("SELECT DISTINCT patient_ID FROM patient_variant ORDER BY patient_ID ASC;")
        patient_list = [row[0] for row in cur.fetchall()]

        cur.execute("SELECT DISTINCT variant FROM variant_annotations ORDER BY variant ASC;")
        variant_list = [row[0] for row in cur.fetchall()]

        cur.execute("SELECT DISTINCT gene FROM variant_annotations ORDER BY gene ASC;")
        gene_list = [row[0] for row in cur.fetchall()]

    return jsonify({
        "patients": patient_list,
        "variants": variant_list,
        "genes": gene_list
    })


# ---------------------------------------------------------------
# Route: Switch database dropdown
# ---------------------------------------------------------------
@app.route("/switch_db", methods=["POST"])
def switch_db():
    """Redirect to a different /query/<db_name> when user selects another database."""
    db_name = request.form.get("db_name")
    if db_name:
        return redirect(url_for("query_page", db_name=db_name))
    flash("No database selected.")
    return redirect(url_for("upload_db"))


# ---------------------------------------------------------------
# Run the app
# ---------------------------------------------------------------
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5006, debug=True)